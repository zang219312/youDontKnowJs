function foo1(a) {
  var b = a * 2

  function bar1(c) {
    console.log(a, b, c)
  }

  bar1(b * 3)
}

foo1(2) // 2 4 12

//  包含着整个全局作用域，其中只有一个标识符：foo。
//  包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。
//  包含着 bar 所创建的作用域，其中只有一个标识符：c。

console.info(
  '🚀 ~ file: chapter-2：词法作用域.js ~ line 12 ~ *',
  `无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处
的位置决定。`
)

console.log('----------------:}-------------------')
// 2.2 欺骗词法  eval、with
//* 2.2.1  eval
function foo2(str, a) {
  eval(str) // 欺骗！
  console.log(a, b) // 1 3
}
var b = 2
foo2('var b = 3;', 1)

/* eval(..) 调用中的"var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代
码声明了一个新的变量b，因此它对已经存在的foo(..) 的词法作用域进行了修改。事实
上，和前面提到的原理一样，这段代码实际上在foo(..) 内部创建了一个变量b，并遮蔽
了外部（全局）作用域中的同名变量。
当console.log(..) 被执行时，会在foo(..) 的内部同时找到a 和b，但是永远也无法找到
外部的b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。 */

//* 2.2.2 with
function foo(obj) {
  with (obj) {
    a = 2
  }
}
var o1 = {
  a: 3
}
var o2 = {
  b: 3
}

foo(o1)
console.log(o1.a) // 2
foo(o2)
console.log(o2.a) // undefined
console.log(a) // 2——不好，a 被泄漏到全局作用域上了！

/**
 * with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，
 * 因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。
 *
 *
 * 尽管with 块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中，
 * 而是被添加到with 所处的函数作用域中。
 *
 */

//* 理解
// 可以这样理解，当我们传递o1 给with 时，with 所声明的作用域是o1，而这个作用域中含有一个同o1.a 属性相符的标识符。
// 但当我们将o2 作为作用域时，其中并没有a 标识符，
// 因此进行了正常的LHS 标识符查找（查看第1 章）。
// o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符a，因此当a＝2 执行
// 时，自动创建了一个全局变量（因为是非严格模式）。

// 另外一个不推荐使用eval(..) 和with 的原因是会被严格模式所影响（限制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用
// eval(..) 也被禁止了。

// 2.2.3 性能

// 2.3 小结
/* JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和with。前者可以对一段包
含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在
运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作
用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。 */
